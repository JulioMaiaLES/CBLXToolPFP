{"ast":null,"code":"import findLevenshteinDistance from '../../levenshtein.esm.js';\nimport { sorted } from '../../helper.esm.js';\nimport { zxcvbnOptions } from '../../Options.esm.js';\nimport MatchReverse from './variants/matching/reverse.esm.js';\nimport MatchL33t from './variants/matching/l33t.esm.js';\nclass MatchDictionary {\n  constructor() {\n    this.l33t = new MatchL33t(this.defaultMatch);\n    this.reverse = new MatchReverse(this.defaultMatch);\n  }\n  match({\n    password\n  }) {\n    const matches = [...this.defaultMatch({\n      password\n    }), ...this.reverse.match({\n      password\n    }), ...this.l33t.match({\n      password\n    })];\n    return sorted(matches);\n  }\n  defaultMatch({\n    password,\n    useLevenshtein = true\n  }) {\n    const matches = [];\n    const passwordLength = password.length;\n    const passwordLower = password.toLowerCase();\n    // eslint-disable-next-line complexity,max-statements\n    Object.keys(zxcvbnOptions.rankedDictionaries).forEach(dictionaryName => {\n      const rankedDict = zxcvbnOptions.rankedDictionaries[dictionaryName];\n      const longestDictionaryWordSize = zxcvbnOptions.rankedDictionariesMaxWordSize[dictionaryName];\n      const searchWidth = Math.min(longestDictionaryWordSize, passwordLength);\n      for (let i = 0; i < passwordLength; i += 1) {\n        const searchEnd = Math.min(i + searchWidth, passwordLength);\n        for (let j = i; j < searchEnd; j += 1) {\n          const usedPassword = passwordLower.slice(i, +j + 1 || 9e9);\n          const isInDictionary = (usedPassword in rankedDict);\n          let foundLevenshteinDistance = {};\n          // only use levenshtein distance on full password to minimize the performance drop\n          // and because otherwise there would be to many false positives\n          const isFullPassword = i === 0 && j === passwordLength - 1;\n          if (zxcvbnOptions.useLevenshteinDistance && isFullPassword && !isInDictionary && useLevenshtein) {\n            foundLevenshteinDistance = findLevenshteinDistance(usedPassword, rankedDict, zxcvbnOptions.levenshteinThreshold);\n          }\n          const isLevenshteinMatch = Object.keys(foundLevenshteinDistance).length !== 0;\n          if (isInDictionary || isLevenshteinMatch) {\n            const usedRankPassword = isLevenshteinMatch ? foundLevenshteinDistance.levenshteinDistanceEntry : usedPassword;\n            const rank = rankedDict[usedRankPassword];\n            matches.push({\n              pattern: 'dictionary',\n              i,\n              j,\n              token: password.slice(i, +j + 1 || 9e9),\n              matchedWord: usedPassword,\n              rank,\n              dictionaryName: dictionaryName,\n              reversed: false,\n              l33t: false,\n              ...foundLevenshteinDistance\n            });\n          }\n        }\n      }\n    });\n    return matches;\n  }\n}\nexport { MatchDictionary as default };","map":{"version":3,"names":["findLevenshteinDistance","sorted","zxcvbnOptions","MatchReverse","MatchL33t","MatchDictionary","constructor","l33t","defaultMatch","reverse","match","password","matches","useLevenshtein","passwordLength","length","passwordLower","toLowerCase","Object","keys","rankedDictionaries","forEach","dictionaryName","rankedDict","longestDictionaryWordSize","rankedDictionariesMaxWordSize","searchWidth","Math","min","i","searchEnd","j","usedPassword","slice","isInDictionary","foundLevenshteinDistance","isFullPassword","useLevenshteinDistance","levenshteinThreshold","isLevenshteinMatch","usedRankPassword","levenshteinDistanceEntry","rank","push","pattern","token","matchedWord","reversed","default"],"sources":["C:/Users/j-mai/Documents/CBLXToolPFP/frontend/node_modules/@zxcvbn-ts/core/dist/matcher/dictionary/matching.esm.js"],"sourcesContent":["import findLevenshteinDistance from '../../levenshtein.esm.js';\nimport { sorted } from '../../helper.esm.js';\nimport { zxcvbnOptions } from '../../Options.esm.js';\nimport MatchReverse from './variants/matching/reverse.esm.js';\nimport MatchL33t from './variants/matching/l33t.esm.js';\n\nclass MatchDictionary {\n  constructor() {\n    this.l33t = new MatchL33t(this.defaultMatch);\n    this.reverse = new MatchReverse(this.defaultMatch);\n  }\n  match({\n    password\n  }) {\n    const matches = [...this.defaultMatch({\n      password\n    }), ...this.reverse.match({\n      password\n    }), ...this.l33t.match({\n      password\n    })];\n    return sorted(matches);\n  }\n  defaultMatch({\n    password,\n    useLevenshtein = true\n  }) {\n    const matches = [];\n    const passwordLength = password.length;\n    const passwordLower = password.toLowerCase();\n    // eslint-disable-next-line complexity,max-statements\n    Object.keys(zxcvbnOptions.rankedDictionaries).forEach(dictionaryName => {\n      const rankedDict = zxcvbnOptions.rankedDictionaries[dictionaryName];\n      const longestDictionaryWordSize = zxcvbnOptions.rankedDictionariesMaxWordSize[dictionaryName];\n      const searchWidth = Math.min(longestDictionaryWordSize, passwordLength);\n      for (let i = 0; i < passwordLength; i += 1) {\n        const searchEnd = Math.min(i + searchWidth, passwordLength);\n        for (let j = i; j < searchEnd; j += 1) {\n          const usedPassword = passwordLower.slice(i, +j + 1 || 9e9);\n          const isInDictionary = (usedPassword in rankedDict);\n          let foundLevenshteinDistance = {};\n          // only use levenshtein distance on full password to minimize the performance drop\n          // and because otherwise there would be to many false positives\n          const isFullPassword = i === 0 && j === passwordLength - 1;\n          if (zxcvbnOptions.useLevenshteinDistance && isFullPassword && !isInDictionary && useLevenshtein) {\n            foundLevenshteinDistance = findLevenshteinDistance(usedPassword, rankedDict, zxcvbnOptions.levenshteinThreshold);\n          }\n          const isLevenshteinMatch = Object.keys(foundLevenshteinDistance).length !== 0;\n          if (isInDictionary || isLevenshteinMatch) {\n            const usedRankPassword = isLevenshteinMatch ? foundLevenshteinDistance.levenshteinDistanceEntry : usedPassword;\n            const rank = rankedDict[usedRankPassword];\n            matches.push({\n              pattern: 'dictionary',\n              i,\n              j,\n              token: password.slice(i, +j + 1 || 9e9),\n              matchedWord: usedPassword,\n              rank,\n              dictionaryName: dictionaryName,\n              reversed: false,\n              l33t: false,\n              ...foundLevenshteinDistance\n            });\n          }\n        }\n      }\n    });\n    return matches;\n  }\n}\n\nexport { MatchDictionary as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
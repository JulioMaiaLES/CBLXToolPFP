{"ast":null,"code":"import { DATE_MIN_YEAR, DATE_MAX_YEAR, REFERENCE_YEAR, DATE_SPLITS } from '../../data/const.esm.js';\nimport { sorted } from '../../helper.esm.js';\n\n/*\r\n * -------------------------------------------------------------------------------\r\n *  date matching ----------------------------------------------------------------\r\n * -------------------------------------------------------------------------------\r\n */\nclass MatchDate {\n  /*\r\n   * a \"date\" is recognized as:\r\n   *   any 3-tuple that starts or ends with a 2- or 4-digit year,\r\n   *   with 2 or 0 separator chars (1.1.91 or 1191),\r\n   *   maybe zero-padded (01-01-91 vs 1-1-91),\r\n   *   a month between 1 and 12,\r\n   *   a day between 1 and 31.\r\n   *\r\n   * note: this isn't true date parsing in that \"feb 31st\" is allowed,\r\n   * this doesn't check for leap years, etc.\r\n   *\r\n   * recipe:\r\n   * start with regex to find maybe-dates, then attempt to map the integers\r\n   * onto month-day-year to filter the maybe-dates into dates.\r\n   * finally, remove matches that are substrings of other matches to reduce noise.\r\n   *\r\n   * note: instead of using a lazy or greedy regex to find many dates over the full string,\r\n   * this uses a ^...$ regex against every substring of the password -- less performant but leads\r\n   * to every possible date match.\r\n   */\n  match({\n    password\n  }) {\n    const matches = [...this.getMatchesWithoutSeparator(password), ...this.getMatchesWithSeparator(password)];\n    const filteredMatches = this.filterNoise(matches);\n    return sorted(filteredMatches);\n  }\n  getMatchesWithSeparator(password) {\n    const matches = [];\n    const maybeDateWithSeparator = /^(\\d{1,4})([\\s/\\\\_.-])(\\d{1,2})\\2(\\d{1,4})$/;\n    // # dates with separators are between length 6 '1/1/91' and 10 '11/11/1991'\n    for (let i = 0; i <= Math.abs(password.length - 6); i += 1) {\n      for (let j = i + 5; j <= i + 9; j += 1) {\n        if (j >= password.length) {\n          break;\n        }\n        const token = password.slice(i, +j + 1 || 9e9);\n        const regexMatch = maybeDateWithSeparator.exec(token);\n        if (regexMatch != null) {\n          const dmy = this.mapIntegersToDayMonthYear([parseInt(regexMatch[1], 10), parseInt(regexMatch[3], 10), parseInt(regexMatch[4], 10)]);\n          if (dmy != null) {\n            matches.push({\n              pattern: 'date',\n              token,\n              i,\n              j,\n              separator: regexMatch[2],\n              year: dmy.year,\n              month: dmy.month,\n              day: dmy.day\n            });\n          }\n        }\n      }\n    }\n    return matches;\n  }\n  // eslint-disable-next-line max-statements\n  getMatchesWithoutSeparator(password) {\n    const matches = [];\n    const maybeDateNoSeparator = /^\\d{4,8}$/;\n    const metric = candidate => Math.abs(candidate.year - REFERENCE_YEAR);\n    // # dates without separators are between length 4 '1191' and 8 '11111991'\n    for (let i = 0; i <= Math.abs(password.length - 4); i += 1) {\n      for (let j = i + 3; j <= i + 7; j += 1) {\n        if (j >= password.length) {\n          break;\n        }\n        const token = password.slice(i, +j + 1 || 9e9);\n        if (maybeDateNoSeparator.exec(token)) {\n          const candidates = [];\n          const index = token.length;\n          const splittedDates = DATE_SPLITS[index];\n          splittedDates.forEach(([k, l]) => {\n            const dmy = this.mapIntegersToDayMonthYear([parseInt(token.slice(0, k), 10), parseInt(token.slice(k, l), 10), parseInt(token.slice(l), 10)]);\n            if (dmy != null) {\n              candidates.push(dmy);\n            }\n          });\n          if (candidates.length > 0) {\n            /*\r\n             * at this point: different possible dmy mappings for the same i,j substring.\r\n             * match the candidate date that likely takes the fewest guesses: a year closest\r\n             * to 2000.\r\n             * (scoring.REFERENCE_YEAR).\r\n             *\r\n             * ie, considering '111504', prefer 11-15-04 to 1-1-1504\r\n             * (interpreting '04' as 2004)\r\n             */\n            let bestCandidate = candidates[0];\n            let minDistance = metric(candidates[0]);\n            candidates.slice(1).forEach(candidate => {\n              const distance = metric(candidate);\n              if (distance < minDistance) {\n                bestCandidate = candidate;\n                minDistance = distance;\n              }\n            });\n            matches.push({\n              pattern: 'date',\n              token,\n              i,\n              j,\n              separator: '',\n              year: bestCandidate.year,\n              month: bestCandidate.month,\n              day: bestCandidate.day\n            });\n          }\n        }\n      }\n    }\n    return matches;\n  }\n  /*\r\n   * matches now contains all valid date strings in a way that is tricky to capture\r\n   * with regexes only. while thorough, it will contain some unintuitive noise:\r\n   *\r\n   * '2015_06_04', in addition to matching 2015_06_04, will also contain\r\n   * 5(!) other date matches: 15_06_04, 5_06_04, ..., even 2015 (matched as 5/1/2020)\r\n   *\r\n   * to reduce noise, remove date matches that are strict substrings of others\r\n   */\n  filterNoise(matches) {\n    return matches.filter(match => {\n      let isSubmatch = false;\n      const matchesLength = matches.length;\n      for (let o = 0; o < matchesLength; o += 1) {\n        const otherMatch = matches[o];\n        if (match !== otherMatch) {\n          if (otherMatch.i <= match.i && otherMatch.j >= match.j) {\n            isSubmatch = true;\n            break;\n          }\n        }\n      }\n      return !isSubmatch;\n    });\n  }\n  /*\r\n   * given a 3-tuple, discard if:\r\n   *   middle int is over 31 (for all dmy formats, years are never allowed in the middle)\r\n   *   middle int is zero\r\n   *   any int is over the max allowable year\r\n   *   any int is over two digits but under the min allowable year\r\n   *   2 integers are over 31, the max allowable day\r\n   *   2 integers are zero\r\n   *   all integers are over 12, the max allowable month\r\n   */\n  // eslint-disable-next-line complexity, max-statements\n  mapIntegersToDayMonthYear(integers) {\n    if (integers[1] > 31 || integers[1] <= 0) {\n      return null;\n    }\n    let over12 = 0;\n    let over31 = 0;\n    let under1 = 0;\n    for (let o = 0, len1 = integers.length; o < len1; o += 1) {\n      const int = integers[o];\n      if (int > 99 && int < DATE_MIN_YEAR || int > DATE_MAX_YEAR) {\n        return null;\n      }\n      if (int > 31) {\n        over31 += 1;\n      }\n      if (int > 12) {\n        over12 += 1;\n      }\n      if (int <= 0) {\n        under1 += 1;\n      }\n    }\n    if (over31 >= 2 || over12 === 3 || under1 >= 2) {\n      return null;\n    }\n    return this.getDayMonth(integers);\n  }\n  // eslint-disable-next-line max-statements\n  getDayMonth(integers) {\n    // first look for a four digit year: yyyy + daymonth or daymonth + yyyy\n    const possibleYearSplits = [[integers[2], integers.slice(0, 2)], [integers[0], integers.slice(1, 3)] // year first\n    ];\n\n    const possibleYearSplitsLength = possibleYearSplits.length;\n    for (let j = 0; j < possibleYearSplitsLength; j += 1) {\n      const [y, rest] = possibleYearSplits[j];\n      if (DATE_MIN_YEAR <= y && y <= DATE_MAX_YEAR) {\n        const dm = this.mapIntegersToDayMonth(rest);\n        if (dm != null) {\n          return {\n            year: y,\n            month: dm.month,\n            day: dm.day\n          };\n        }\n        /*\r\n         * for a candidate that includes a four-digit year,\r\n         * when the remaining integers don't match to a day and month,\r\n         * it is not a date.\r\n         */\n        return null;\n      }\n    }\n    // given no four-digit year, two digit years are the most flexible int to match, so\n    // try to parse a day-month out of integers[0..1] or integers[1..0]\n    for (let k = 0; k < possibleYearSplitsLength; k += 1) {\n      const [y, rest] = possibleYearSplits[k];\n      const dm = this.mapIntegersToDayMonth(rest);\n      if (dm != null) {\n        return {\n          year: this.twoToFourDigitYear(y),\n          month: dm.month,\n          day: dm.day\n        };\n      }\n    }\n    return null;\n  }\n  mapIntegersToDayMonth(integers) {\n    const temp = [integers, integers.slice().reverse()];\n    for (let i = 0; i < temp.length; i += 1) {\n      const data = temp[i];\n      const day = data[0];\n      const month = data[1];\n      if (day >= 1 && day <= 31 && month >= 1 && month <= 12) {\n        return {\n          day,\n          month\n        };\n      }\n    }\n    return null;\n  }\n  twoToFourDigitYear(year) {\n    if (year > 99) {\n      return year;\n    }\n    if (year > 50) {\n      // 87 -> 1987\n      return year + 1900;\n    }\n    // 15 -> 2015\n    return year + 2000;\n  }\n}\nexport { MatchDate as default };","map":{"version":3,"names":["DATE_MIN_YEAR","DATE_MAX_YEAR","REFERENCE_YEAR","DATE_SPLITS","sorted","MatchDate","match","password","matches","getMatchesWithoutSeparator","getMatchesWithSeparator","filteredMatches","filterNoise","maybeDateWithSeparator","i","Math","abs","length","j","token","slice","regexMatch","exec","dmy","mapIntegersToDayMonthYear","parseInt","push","pattern","separator","year","month","day","maybeDateNoSeparator","metric","candidate","candidates","index","splittedDates","forEach","k","l","bestCandidate","minDistance","distance","filter","isSubmatch","matchesLength","o","otherMatch","integers","over12","over31","under1","len1","int","getDayMonth","possibleYearSplits","possibleYearSplitsLength","y","rest","dm","mapIntegersToDayMonth","twoToFourDigitYear","temp","reverse","data","default"],"sources":["C:/Users/Julio/Documents/Projects/CBLXToolPFP/frontend/node_modules/@zxcvbn-ts/core/dist/matcher/date/matching.esm.js"],"sourcesContent":["import { DATE_MIN_YEAR, DATE_MAX_YEAR, REFERENCE_YEAR, DATE_SPLITS } from '../../data/const.esm.js';\r\nimport { sorted } from '../../helper.esm.js';\r\n\r\n/*\r\n * -------------------------------------------------------------------------------\r\n *  date matching ----------------------------------------------------------------\r\n * -------------------------------------------------------------------------------\r\n */\r\nclass MatchDate {\r\n  /*\r\n   * a \"date\" is recognized as:\r\n   *   any 3-tuple that starts or ends with a 2- or 4-digit year,\r\n   *   with 2 or 0 separator chars (1.1.91 or 1191),\r\n   *   maybe zero-padded (01-01-91 vs 1-1-91),\r\n   *   a month between 1 and 12,\r\n   *   a day between 1 and 31.\r\n   *\r\n   * note: this isn't true date parsing in that \"feb 31st\" is allowed,\r\n   * this doesn't check for leap years, etc.\r\n   *\r\n   * recipe:\r\n   * start with regex to find maybe-dates, then attempt to map the integers\r\n   * onto month-day-year to filter the maybe-dates into dates.\r\n   * finally, remove matches that are substrings of other matches to reduce noise.\r\n   *\r\n   * note: instead of using a lazy or greedy regex to find many dates over the full string,\r\n   * this uses a ^...$ regex against every substring of the password -- less performant but leads\r\n   * to every possible date match.\r\n   */\r\n  match({\r\n    password\r\n  }) {\r\n    const matches = [...this.getMatchesWithoutSeparator(password), ...this.getMatchesWithSeparator(password)];\r\n    const filteredMatches = this.filterNoise(matches);\r\n    return sorted(filteredMatches);\r\n  }\r\n  getMatchesWithSeparator(password) {\r\n    const matches = [];\r\n    const maybeDateWithSeparator = /^(\\d{1,4})([\\s/\\\\_.-])(\\d{1,2})\\2(\\d{1,4})$/;\r\n    // # dates with separators are between length 6 '1/1/91' and 10 '11/11/1991'\r\n    for (let i = 0; i <= Math.abs(password.length - 6); i += 1) {\r\n      for (let j = i + 5; j <= i + 9; j += 1) {\r\n        if (j >= password.length) {\r\n          break;\r\n        }\r\n        const token = password.slice(i, +j + 1 || 9e9);\r\n        const regexMatch = maybeDateWithSeparator.exec(token);\r\n        if (regexMatch != null) {\r\n          const dmy = this.mapIntegersToDayMonthYear([parseInt(regexMatch[1], 10), parseInt(regexMatch[3], 10), parseInt(regexMatch[4], 10)]);\r\n          if (dmy != null) {\r\n            matches.push({\r\n              pattern: 'date',\r\n              token,\r\n              i,\r\n              j,\r\n              separator: regexMatch[2],\r\n              year: dmy.year,\r\n              month: dmy.month,\r\n              day: dmy.day\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return matches;\r\n  }\r\n  // eslint-disable-next-line max-statements\r\n  getMatchesWithoutSeparator(password) {\r\n    const matches = [];\r\n    const maybeDateNoSeparator = /^\\d{4,8}$/;\r\n    const metric = candidate => Math.abs(candidate.year - REFERENCE_YEAR);\r\n    // # dates without separators are between length 4 '1191' and 8 '11111991'\r\n    for (let i = 0; i <= Math.abs(password.length - 4); i += 1) {\r\n      for (let j = i + 3; j <= i + 7; j += 1) {\r\n        if (j >= password.length) {\r\n          break;\r\n        }\r\n        const token = password.slice(i, +j + 1 || 9e9);\r\n        if (maybeDateNoSeparator.exec(token)) {\r\n          const candidates = [];\r\n          const index = token.length;\r\n          const splittedDates = DATE_SPLITS[index];\r\n          splittedDates.forEach(([k, l]) => {\r\n            const dmy = this.mapIntegersToDayMonthYear([parseInt(token.slice(0, k), 10), parseInt(token.slice(k, l), 10), parseInt(token.slice(l), 10)]);\r\n            if (dmy != null) {\r\n              candidates.push(dmy);\r\n            }\r\n          });\r\n          if (candidates.length > 0) {\r\n            /*\r\n             * at this point: different possible dmy mappings for the same i,j substring.\r\n             * match the candidate date that likely takes the fewest guesses: a year closest\r\n             * to 2000.\r\n             * (scoring.REFERENCE_YEAR).\r\n             *\r\n             * ie, considering '111504', prefer 11-15-04 to 1-1-1504\r\n             * (interpreting '04' as 2004)\r\n             */\r\n            let bestCandidate = candidates[0];\r\n            let minDistance = metric(candidates[0]);\r\n            candidates.slice(1).forEach(candidate => {\r\n              const distance = metric(candidate);\r\n              if (distance < minDistance) {\r\n                bestCandidate = candidate;\r\n                minDistance = distance;\r\n              }\r\n            });\r\n            matches.push({\r\n              pattern: 'date',\r\n              token,\r\n              i,\r\n              j,\r\n              separator: '',\r\n              year: bestCandidate.year,\r\n              month: bestCandidate.month,\r\n              day: bestCandidate.day\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return matches;\r\n  }\r\n  /*\r\n   * matches now contains all valid date strings in a way that is tricky to capture\r\n   * with regexes only. while thorough, it will contain some unintuitive noise:\r\n   *\r\n   * '2015_06_04', in addition to matching 2015_06_04, will also contain\r\n   * 5(!) other date matches: 15_06_04, 5_06_04, ..., even 2015 (matched as 5/1/2020)\r\n   *\r\n   * to reduce noise, remove date matches that are strict substrings of others\r\n   */\r\n  filterNoise(matches) {\r\n    return matches.filter(match => {\r\n      let isSubmatch = false;\r\n      const matchesLength = matches.length;\r\n      for (let o = 0; o < matchesLength; o += 1) {\r\n        const otherMatch = matches[o];\r\n        if (match !== otherMatch) {\r\n          if (otherMatch.i <= match.i && otherMatch.j >= match.j) {\r\n            isSubmatch = true;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      return !isSubmatch;\r\n    });\r\n  }\r\n  /*\r\n   * given a 3-tuple, discard if:\r\n   *   middle int is over 31 (for all dmy formats, years are never allowed in the middle)\r\n   *   middle int is zero\r\n   *   any int is over the max allowable year\r\n   *   any int is over two digits but under the min allowable year\r\n   *   2 integers are over 31, the max allowable day\r\n   *   2 integers are zero\r\n   *   all integers are over 12, the max allowable month\r\n   */\r\n  // eslint-disable-next-line complexity, max-statements\r\n  mapIntegersToDayMonthYear(integers) {\r\n    if (integers[1] > 31 || integers[1] <= 0) {\r\n      return null;\r\n    }\r\n    let over12 = 0;\r\n    let over31 = 0;\r\n    let under1 = 0;\r\n    for (let o = 0, len1 = integers.length; o < len1; o += 1) {\r\n      const int = integers[o];\r\n      if (int > 99 && int < DATE_MIN_YEAR || int > DATE_MAX_YEAR) {\r\n        return null;\r\n      }\r\n      if (int > 31) {\r\n        over31 += 1;\r\n      }\r\n      if (int > 12) {\r\n        over12 += 1;\r\n      }\r\n      if (int <= 0) {\r\n        under1 += 1;\r\n      }\r\n    }\r\n    if (over31 >= 2 || over12 === 3 || under1 >= 2) {\r\n      return null;\r\n    }\r\n    return this.getDayMonth(integers);\r\n  }\r\n  // eslint-disable-next-line max-statements\r\n  getDayMonth(integers) {\r\n    // first look for a four digit year: yyyy + daymonth or daymonth + yyyy\r\n    const possibleYearSplits = [[integers[2], integers.slice(0, 2)], [integers[0], integers.slice(1, 3)] // year first\r\n    ];\r\n\r\n    const possibleYearSplitsLength = possibleYearSplits.length;\r\n    for (let j = 0; j < possibleYearSplitsLength; j += 1) {\r\n      const [y, rest] = possibleYearSplits[j];\r\n      if (DATE_MIN_YEAR <= y && y <= DATE_MAX_YEAR) {\r\n        const dm = this.mapIntegersToDayMonth(rest);\r\n        if (dm != null) {\r\n          return {\r\n            year: y,\r\n            month: dm.month,\r\n            day: dm.day\r\n          };\r\n        }\r\n        /*\r\n         * for a candidate that includes a four-digit year,\r\n         * when the remaining integers don't match to a day and month,\r\n         * it is not a date.\r\n         */\r\n        return null;\r\n      }\r\n    }\r\n    // given no four-digit year, two digit years are the most flexible int to match, so\r\n    // try to parse a day-month out of integers[0..1] or integers[1..0]\r\n    for (let k = 0; k < possibleYearSplitsLength; k += 1) {\r\n      const [y, rest] = possibleYearSplits[k];\r\n      const dm = this.mapIntegersToDayMonth(rest);\r\n      if (dm != null) {\r\n        return {\r\n          year: this.twoToFourDigitYear(y),\r\n          month: dm.month,\r\n          day: dm.day\r\n        };\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n  mapIntegersToDayMonth(integers) {\r\n    const temp = [integers, integers.slice().reverse()];\r\n    for (let i = 0; i < temp.length; i += 1) {\r\n      const data = temp[i];\r\n      const day = data[0];\r\n      const month = data[1];\r\n      if (day >= 1 && day <= 31 && month >= 1 && month <= 12) {\r\n        return {\r\n          day,\r\n          month\r\n        };\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n  twoToFourDigitYear(year) {\r\n    if (year > 99) {\r\n      return year;\r\n    }\r\n    if (year > 50) {\r\n      // 87 -> 1987\r\n      return year + 1900;\r\n    }\r\n    // 15 -> 2015\r\n    return year + 2000;\r\n  }\r\n}\r\n\r\nexport { MatchDate as default };\r\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
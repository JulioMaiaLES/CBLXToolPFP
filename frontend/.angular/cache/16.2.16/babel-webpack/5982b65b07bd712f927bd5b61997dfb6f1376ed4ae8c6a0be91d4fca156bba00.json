{"ast":null,"code":"import { HttpParams } from '@angular/common/http';\nimport { environment } from '@env';\nimport { catchError, retry, throwError } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"@services/storage.service\";\nimport * as i3 from \"angular-notifier\";\nimport * as i4 from \"./object.service\";\nimport * as i5 from \"./language.service\";\nexport class HttpService {\n  constructor(http, storage, notifier, objectService, language) {\n    this.http = http;\n    this.storage = storage;\n    this.notifier = notifier;\n    this.objectService = objectService;\n    this.language = language;\n    this.base_url = environment.base_url;\n    this.repeat = 1;\n    this.handleError = error => {\n      // this.notifier.notify(\n      //   'error',\n      //   error.error.detail ||\n      //     error.error.message ||\n      //     'Não foi possível completar a ação'\n      // );\n      return throwError(() => error);\n    };\n  }\n  getBodyType(body) {\n    if (!(body instanceof HttpParams)) {\n      this.objectService.removeEmptyValues(body);\n    }\n    return body instanceof HttpParams ? 'x-www-form-urlencoded' : 'json';\n  }\n  getUrl(url) {\n    if (url.includes('http')) return url;\n    return this.base_url + url;\n  }\n  getHeaders(application = 'json', config) {\n    const headers = {\n      'Content-Type': `application/${application}`,\n      'Accept-Language': this.language.current,\n      Authorization: ''\n    };\n    if (this.storage.token && config.token) {\n      headers.Authorization = 'token ' + this.storage.token;\n    }\n    return headers;\n  }\n  validateConfig(config) {\n    if (!config) config = {};\n    if (typeof config.token !== 'boolean') config.token = true;\n    return config;\n  }\n  /**\n   * ### Método GET\n   * Espera receber um parametro de tipo sendo o tipo de retorno da requisição\n   *\n   * *O Content-Type é application/json*\n   *\n   * @param url URL da requisição (a falta do http acarretará na concatenação com o base_url)\n   * @param params *opcinal* - Query parametros da requisição (itens depois do **?** na url)\n   * @param config *opcional* - Configurações da requisição (veja a interface HttpConfig)\n   * @returns Retorna um Observable de sua requisição\n   */\n  get(url, params, config) {\n    config = this.validateConfig(config);\n    const headers = this.getHeaders('json', config);\n    return this.http.get(this.getUrl(url), {\n      headers,\n      params\n    }).pipe(retry(this.repeat), catchError(this.handleError));\n  }\n  /**\n   * ### Método POST\n   * Espera receber um parametro de tipo sendo o tipo de retorno da requisição.\n   *\n   * *O Content-Type será automático com base no tipo de seu body*\n   *\n   * @param url URL da requisição (a falta do http acarretará na concatenação com o base_url)\n   * @param body Corpo da requisição\n   * @param params *opcinal* - Query parametros da requisição (itens depois do **?** na url)\n   * @param config *opcional* - Configurações da requisição (veja a interface HttpConfig)\n   * @returns Retorna um Observable de sua requisição\n   */\n  post(url, body, params, config) {\n    const application = this.getBodyType(body);\n    config = this.validateConfig(config);\n    const headers = this.getHeaders(application, config);\n    const _body = application === 'json' ? JSON.stringify(body) : body;\n    return this.http.post(this.getUrl(url), _body, {\n      headers,\n      params\n    }).pipe(retry(this.repeat), catchError(this.handleError));\n  }\n  /**\n   * ### Método PATCH\n   * Espera receber um parametro de tipo sendo o tipo de retorno da requisição.\n   *\n   * *O Content-Type será automático com base no tipo de seu body*\n   *\n   * @param url URL da requisição (a falta do http acarretará na concatenação com o base_url)\n   * @param body Corpo da requisição\n   * @param params *opcinal* - Query parametros da requisição (itens depois do **?** na url)\n   * @param config *opcional* - Configurações da requisição (veja a interface HttpConfig)\n   * @returns Retorna um Observable de sua requisição\n   */\n  patch(url, body, params, config) {\n    const application = this.getBodyType(body);\n    config = this.validateConfig(config);\n    const headers = this.getHeaders(application, config);\n    const _body = application === 'json' ? JSON.stringify(body) : body;\n    return this.http.patch(this.getUrl(url), _body, {\n      headers,\n      params\n    }).pipe(retry(this.repeat), catchError(this.handleError));\n  }\n  /**\n   * ### Método DELETE\n   * Espera receber um parametro de tipo sendo o tipo de retorno da requisição\n   *\n   * *O Content-Type é application/json*\n   *\n   * @param url URL da requisição (a falta do http acarretará na concatenação com o base_url)\n   * @param params *opcinal* - Query parametros da requisição (itens depois do **?** na url)\n   * @param config *opcional* - Configurações da requisição (veja a interface HttpConfig)\n   * @returns Retorna um Observable de sua requisição\n   */\n  delete(url, params, config) {\n    config = this.validateConfig(config);\n    const headers = this.getHeaders('json', config);\n    return this.http.delete(this.getUrl(url), {\n      headers,\n      params\n    }).pipe(retry(this.repeat), catchError(this.handleError));\n  }\n  static {\n    this.ɵfac = function HttpService_Factory(t) {\n      return new (t || HttpService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.StorageService), i0.ɵɵinject(i3.NotifierService), i0.ɵɵinject(i4.ObjectService), i0.ɵɵinject(i5.LanguageService));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: HttpService,\n      factory: HttpService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"names":["HttpParams","environment","catchError","retry","throwError","HttpService","constructor","http","storage","notifier","objectService","language","base_url","repeat","handleError","error","getBodyType","body","removeEmptyValues","getUrl","url","includes","getHeaders","application","config","headers","current","Authorization","token","validateConfig","get","params","pipe","post","_body","JSON","stringify","patch","delete","i0","ɵɵinject","i1","HttpClient","i2","StorageService","i3","NotifierService","i4","ObjectService","i5","LanguageService","factory","ɵfac","providedIn"],"sources":["C:\\Users\\j-mai\\Documents\\CBLXToolPFP\\frontend\\src\\app\\services\\http.service.ts"],"sourcesContent":["import {\n  HttpClient,\n  HttpErrorResponse,\n  HttpParams,\n} from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { environment } from '@env';\nimport { StorageService } from '@services/storage.service';\nimport { NotifierService } from 'angular-notifier';\nimport { catchError, retry, throwError } from 'rxjs';\nimport { LanguageService } from './language.service';\nimport { ObjectService } from './object.service';\n\nexport interface BodyJson {\n  [key: string]: unknown;\n}\n\nexport interface HttpConfig {\n  token: boolean;\n}\n\ntype ApplicationsTypes = 'json' | 'x-www-form-urlencoded';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class HttpService {\n  constructor(\n    private http: HttpClient,\n    private storage: StorageService,\n    private notifier: NotifierService,\n    private objectService: ObjectService,\n    private language: LanguageService\n  ) {}\n\n  public base_url = environment.base_url;\n  private repeat = 1;\n\n  private getBodyType(body: BodyJson | HttpParams): ApplicationsTypes {\n    if (!(body instanceof HttpParams)) {\n      this.objectService.removeEmptyValues(body);\n    }\n    return body instanceof HttpParams ? 'x-www-form-urlencoded' : 'json';\n  }\n\n  private getUrl(url: string) {\n    if (url.includes('http')) return url;\n    return this.base_url + url;\n  }\n\n  private getHeaders(\n    application: ApplicationsTypes = 'json',\n    config: HttpConfig\n  ) {\n    const headers = {\n      'Content-Type': `application/${application}`,\n      'Accept-Language': this.language.current,\n      Authorization: '',\n    };\n    if (this.storage.token && config.token) {\n      headers.Authorization = 'token ' + this.storage.token;\n    }\n\n    return headers;\n  }\n\n  private handleError = (error: HttpErrorResponse) => {\n    // this.notifier.notify(\n    //   'error',\n    //   error.error.detail ||\n    //     error.error.message ||\n    //     'Não foi possível completar a ação'\n    // );\n    return throwError(() => error);\n  };\n\n  private validateConfig(config?: HttpConfig) {\n    if (!config) config = {} as HttpConfig;\n    if (typeof config.token !== 'boolean') config.token = true;\n    return config;\n  }\n\n  /**\n   * ### Método GET\n   * Espera receber um parametro de tipo sendo o tipo de retorno da requisição\n   *\n   * *O Content-Type é application/json*\n   *\n   * @param url URL da requisição (a falta do http acarretará na concatenação com o base_url)\n   * @param params *opcinal* - Query parametros da requisição (itens depois do **?** na url)\n   * @param config *opcional* - Configurações da requisição (veja a interface HttpConfig)\n   * @returns Retorna um Observable de sua requisição\n   */\n  get<T>(url: string, params?: HttpParams, config?: HttpConfig) {\n    config = this.validateConfig(config);\n    const headers = this.getHeaders('json', config);\n    return this.http\n      .get<T>(this.getUrl(url), { headers, params })\n      .pipe(retry(this.repeat), catchError(this.handleError));\n  }\n\n  /**\n   * ### Método POST\n   * Espera receber um parametro de tipo sendo o tipo de retorno da requisição.\n   *\n   * *O Content-Type será automático com base no tipo de seu body*\n   *\n   * @param url URL da requisição (a falta do http acarretará na concatenação com o base_url)\n   * @param body Corpo da requisição\n   * @param params *opcinal* - Query parametros da requisição (itens depois do **?** na url)\n   * @param config *opcional* - Configurações da requisição (veja a interface HttpConfig)\n   * @returns Retorna um Observable de sua requisição\n   */\n  post<T>(\n    url: string,\n    body: HttpParams | BodyJson,\n    params?: HttpParams,\n    config?: HttpConfig\n  ) {\n    const application = this.getBodyType(body);\n    config = this.validateConfig(config);\n    const headers = this.getHeaders(application, config);\n    const _body = application === 'json' ? JSON.stringify(body) : body;\n\n    return this.http\n      .post<T>(this.getUrl(url), _body, {\n        headers,\n        params,\n      })\n      .pipe(retry(this.repeat), catchError(this.handleError));\n  }\n\n  /**\n   * ### Método PATCH\n   * Espera receber um parametro de tipo sendo o tipo de retorno da requisição.\n   *\n   * *O Content-Type será automático com base no tipo de seu body*\n   *\n   * @param url URL da requisição (a falta do http acarretará na concatenação com o base_url)\n   * @param body Corpo da requisição\n   * @param params *opcinal* - Query parametros da requisição (itens depois do **?** na url)\n   * @param config *opcional* - Configurações da requisição (veja a interface HttpConfig)\n   * @returns Retorna um Observable de sua requisição\n   */\n  patch<T>(\n    url: string,\n    body: HttpParams | BodyJson,\n    params?: HttpParams,\n    config?: HttpConfig\n  ) {\n    const application = this.getBodyType(body);\n    config = this.validateConfig(config);\n    const headers = this.getHeaders(application, config);\n    const _body = application === 'json' ? JSON.stringify(body) : body;\n\n    return this.http\n      .patch<T>(this.getUrl(url), _body, { headers, params })\n      .pipe(retry(this.repeat), catchError(this.handleError));\n  }\n\n  /**\n   * ### Método DELETE\n   * Espera receber um parametro de tipo sendo o tipo de retorno da requisição\n   *\n   * *O Content-Type é application/json*\n   *\n   * @param url URL da requisição (a falta do http acarretará na concatenação com o base_url)\n   * @param params *opcinal* - Query parametros da requisição (itens depois do **?** na url)\n   * @param config *opcional* - Configurações da requisição (veja a interface HttpConfig)\n   * @returns Retorna um Observable de sua requisição\n   */\n  delete<T>(url: string, params?: HttpParams, config?: HttpConfig) {\n    config = this.validateConfig(config);\n    const headers = this.getHeaders('json', config);\n    return this.http\n      .delete<T>(this.getUrl(url), { headers, params })\n      .pipe(retry(this.repeat), catchError(this.handleError));\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
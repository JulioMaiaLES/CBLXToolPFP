{"ast":null,"code":"class CleanPasswords {\n  constructor({\n    substr,\n    limit,\n    trieRoot\n  }) {\n    this.buffer = [];\n    this.finalPasswords = [];\n    this.substr = substr;\n    this.limit = limit;\n    this.trieRoot = trieRoot;\n  }\n  getAllPossibleSubsAtIndex(index) {\n    const nodes = [];\n    let cur = this.trieRoot;\n    for (let i = index; i < this.substr.length; i += 1) {\n      const character = this.substr.charAt(i);\n      cur = cur.getChild(character);\n      if (!cur) {\n        break;\n      }\n      nodes.push(cur);\n    }\n    return nodes;\n  }\n  // eslint-disable-next-line complexity,max-statements\n  helper({\n    onlyFullSub,\n    isFullSub,\n    index,\n    subIndex,\n    changes,\n    lastSubLetter,\n    consecutiveSubCount\n  }) {\n    if (this.finalPasswords.length >= this.limit) {\n      return;\n    }\n    if (index === this.substr.length) {\n      if (onlyFullSub === isFullSub) {\n        this.finalPasswords.push({\n          password: this.buffer.join(''),\n          changes\n        });\n      }\n      return;\n    }\n    // first, exhaust all possible substitutions at this index\n    const nodes = [...this.getAllPossibleSubsAtIndex(index)];\n    let hasSubs = false;\n    // iterate backward to get wider substitutions first\n    for (let i = index + nodes.length - 1; i >= index; i -= 1) {\n      const cur = nodes[i - index];\n      if (cur.isTerminal()) {\n        // Skip if this would be a 4th or more consecutive substitution of the same letter\n        // this should work in all language as there shouldn't be the same letter more than four times in a row\n        // So we can ignore the rest to save calculation time\n        if (lastSubLetter === cur.parents.join('') && consecutiveSubCount >= 3) {\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n        hasSubs = true;\n        const subs = cur.subs;\n        // eslint-disable-next-line no-restricted-syntax\n        for (const sub of subs) {\n          this.buffer.push(sub);\n          const newSubs = changes.concat({\n            i: subIndex,\n            letter: sub,\n            substitution: cur.parents.join('')\n          });\n          // recursively build the rest of the string\n          this.helper({\n            onlyFullSub,\n            isFullSub,\n            index: i + 1,\n            subIndex: subIndex + sub.length,\n            changes: newSubs,\n            lastSubLetter: cur.parents.join(''),\n            consecutiveSubCount: lastSubLetter === cur.parents.join('') ? consecutiveSubCount + 1 : 1\n          });\n          // backtrack by ignoring the added postfix\n          this.buffer.pop();\n          if (this.finalPasswords.length >= this.limit) {\n            return;\n          }\n        }\n      }\n    }\n    // next, generate all combos without doing a substitution at this index\n    // if a partial substitution is requested or there are no substitutions at this index\n    if (!onlyFullSub || !hasSubs) {\n      const firstChar = this.substr.charAt(index);\n      this.buffer.push(firstChar);\n      this.helper({\n        onlyFullSub,\n        isFullSub: isFullSub && !hasSubs,\n        index: index + 1,\n        subIndex: subIndex + 1,\n        changes,\n        lastSubLetter,\n        consecutiveSubCount\n      });\n      this.buffer.pop();\n    }\n  }\n  getAll() {\n    // only full substitution\n    this.helper({\n      onlyFullSub: true,\n      isFullSub: true,\n      index: 0,\n      subIndex: 0,\n      changes: [],\n      lastSubLetter: undefined,\n      consecutiveSubCount: 0\n    });\n    // only partial substitution\n    this.helper({\n      onlyFullSub: false,\n      isFullSub: true,\n      index: 0,\n      subIndex: 0,\n      changes: [],\n      lastSubLetter: undefined,\n      consecutiveSubCount: 0\n    });\n    return this.finalPasswords;\n  }\n}\nconst getCleanPasswords = (password, limit, trieRoot) => {\n  const helper = new CleanPasswords({\n    substr: password,\n    limit,\n    trieRoot\n  });\n  return helper.getAll();\n};\nexport { getCleanPasswords as default };","map":{"version":3,"names":["CleanPasswords","constructor","substr","limit","trieRoot","buffer","finalPasswords","getAllPossibleSubsAtIndex","index","nodes","cur","i","length","character","charAt","getChild","push","helper","onlyFullSub","isFullSub","subIndex","changes","lastSubLetter","consecutiveSubCount","password","join","hasSubs","isTerminal","parents","subs","sub","newSubs","concat","letter","substitution","pop","firstChar","getAll","undefined","getCleanPasswords","default"],"sources":["C:/Users/j-mai/Documents/CBLXToolPFP/frontend/node_modules/@zxcvbn-ts/core/dist/matcher/dictionary/variants/matching/unmunger/getCleanPasswords.esm.js"],"sourcesContent":["class CleanPasswords {\n  constructor({\n    substr,\n    limit,\n    trieRoot\n  }) {\n    this.buffer = [];\n    this.finalPasswords = [];\n    this.substr = substr;\n    this.limit = limit;\n    this.trieRoot = trieRoot;\n  }\n  getAllPossibleSubsAtIndex(index) {\n    const nodes = [];\n    let cur = this.trieRoot;\n    for (let i = index; i < this.substr.length; i += 1) {\n      const character = this.substr.charAt(i);\n      cur = cur.getChild(character);\n      if (!cur) {\n        break;\n      }\n      nodes.push(cur);\n    }\n    return nodes;\n  }\n  // eslint-disable-next-line complexity,max-statements\n  helper({\n    onlyFullSub,\n    isFullSub,\n    index,\n    subIndex,\n    changes,\n    lastSubLetter,\n    consecutiveSubCount\n  }) {\n    if (this.finalPasswords.length >= this.limit) {\n      return;\n    }\n    if (index === this.substr.length) {\n      if (onlyFullSub === isFullSub) {\n        this.finalPasswords.push({\n          password: this.buffer.join(''),\n          changes\n        });\n      }\n      return;\n    }\n    // first, exhaust all possible substitutions at this index\n    const nodes = [...this.getAllPossibleSubsAtIndex(index)];\n    let hasSubs = false;\n    // iterate backward to get wider substitutions first\n    for (let i = index + nodes.length - 1; i >= index; i -= 1) {\n      const cur = nodes[i - index];\n      if (cur.isTerminal()) {\n        // Skip if this would be a 4th or more consecutive substitution of the same letter\n        // this should work in all language as there shouldn't be the same letter more than four times in a row\n        // So we can ignore the rest to save calculation time\n        if (lastSubLetter === cur.parents.join('') && consecutiveSubCount >= 3) {\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n        hasSubs = true;\n        const subs = cur.subs;\n        // eslint-disable-next-line no-restricted-syntax\n        for (const sub of subs) {\n          this.buffer.push(sub);\n          const newSubs = changes.concat({\n            i: subIndex,\n            letter: sub,\n            substitution: cur.parents.join('')\n          });\n          // recursively build the rest of the string\n          this.helper({\n            onlyFullSub,\n            isFullSub,\n            index: i + 1,\n            subIndex: subIndex + sub.length,\n            changes: newSubs,\n            lastSubLetter: cur.parents.join(''),\n            consecutiveSubCount: lastSubLetter === cur.parents.join('') ? consecutiveSubCount + 1 : 1\n          });\n          // backtrack by ignoring the added postfix\n          this.buffer.pop();\n          if (this.finalPasswords.length >= this.limit) {\n            return;\n          }\n        }\n      }\n    }\n    // next, generate all combos without doing a substitution at this index\n    // if a partial substitution is requested or there are no substitutions at this index\n    if (!onlyFullSub || !hasSubs) {\n      const firstChar = this.substr.charAt(index);\n      this.buffer.push(firstChar);\n      this.helper({\n        onlyFullSub,\n        isFullSub: isFullSub && !hasSubs,\n        index: index + 1,\n        subIndex: subIndex + 1,\n        changes,\n        lastSubLetter,\n        consecutiveSubCount\n      });\n      this.buffer.pop();\n    }\n  }\n  getAll() {\n    // only full substitution\n    this.helper({\n      onlyFullSub: true,\n      isFullSub: true,\n      index: 0,\n      subIndex: 0,\n      changes: [],\n      lastSubLetter: undefined,\n      consecutiveSubCount: 0\n    });\n    // only partial substitution\n    this.helper({\n      onlyFullSub: false,\n      isFullSub: true,\n      index: 0,\n      subIndex: 0,\n      changes: [],\n      lastSubLetter: undefined,\n      consecutiveSubCount: 0\n    });\n    return this.finalPasswords;\n  }\n}\nconst getCleanPasswords = (password, limit, trieRoot) => {\n  const helper = new CleanPasswords({\n    substr: password,\n    limit,\n    trieRoot\n  });\n  return helper.getAll();\n};\n\nexport { getCleanPasswords as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
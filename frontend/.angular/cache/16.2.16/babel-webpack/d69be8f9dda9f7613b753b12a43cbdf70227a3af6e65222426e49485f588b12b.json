{"ast":null,"code":"import { extend, sorted } from '../../helper.esm.js';\nimport { zxcvbnOptions } from '../../Options.esm.js';\n\n/*\n * ------------------------------------------------------------------------------\n * spatial match (qwerty/dvorak/keypad and so on) -----------------------------------------\n * ------------------------------------------------------------------------------\n */\nclass MatchSpatial {\n  constructor() {\n    this.SHIFTED_RX = /[~!@#$%^&*()_+QWERTYUIOP{}|ASDFGHJKL:\"ZXCVBNM<>?]/;\n  }\n  match({\n    password\n  }) {\n    const matches = [];\n    Object.keys(zxcvbnOptions.graphs).forEach(graphName => {\n      const graph = zxcvbnOptions.graphs[graphName];\n      extend(matches, this.helper(password, graph, graphName));\n    });\n    return sorted(matches);\n  }\n  checkIfShifted(graphName, password, index) {\n    if (!graphName.includes('keypad') &&\n    // initial character is shifted\n    this.SHIFTED_RX.test(password.charAt(index))) {\n      return 1;\n    }\n    return 0;\n  }\n  // eslint-disable-next-line complexity, max-statements\n  helper(password, graph, graphName) {\n    let shiftedCount;\n    const matches = [];\n    let i = 0;\n    const passwordLength = password.length;\n    while (i < passwordLength - 1) {\n      let j = i + 1;\n      let lastDirection = null;\n      let turns = 0;\n      shiftedCount = this.checkIfShifted(graphName, password, i);\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        const prevChar = password.charAt(j - 1);\n        const adjacents = graph[prevChar] || [];\n        let found = false;\n        let foundDirection = -1;\n        let curDirection = -1;\n        // consider growing pattern by one character if j hasn't gone over the edge.\n        if (j < passwordLength) {\n          const curChar = password.charAt(j);\n          const adjacentsLength = adjacents.length;\n          for (let k = 0; k < adjacentsLength; k += 1) {\n            const adjacent = adjacents[k];\n            curDirection += 1;\n            // eslint-disable-next-line max-depth\n            if (adjacent) {\n              const adjacentIndex = adjacent.indexOf(curChar);\n              // eslint-disable-next-line max-depth\n              if (adjacentIndex !== -1) {\n                found = true;\n                foundDirection = curDirection;\n                // eslint-disable-next-line max-depth\n                if (adjacentIndex === 1) {\n                  // # index 1 in the adjacency means the key is shifted,\n                  // # 0 means unshifted: A vs a, % vs 5, etc.\n                  // # for example, 'q' is adjacent to the entry '2@'.\n                  // # @ is shifted w/ index 1, 2 is unshifted.\n                  shiftedCount += 1;\n                }\n                // eslint-disable-next-line max-depth\n                if (lastDirection !== foundDirection) {\n                  // # adding a turn is correct even in the initial\n                  // case when last_direction is null:\n                  // # every spatial pattern starts with a turn.\n                  turns += 1;\n                  lastDirection = foundDirection;\n                }\n                break;\n              }\n            }\n          }\n        }\n        // if the current pattern continued, extend j and try to grow again\n        if (found) {\n          j += 1;\n          // otherwise push the pattern discovered so far, if any...\n        } else {\n          // don't consider length 1 or 2 chains.\n          if (j - i > 2) {\n            matches.push({\n              pattern: 'spatial',\n              i,\n              j: j - 1,\n              token: password.slice(i, j),\n              graph: graphName,\n              turns,\n              shiftedCount\n            });\n          }\n          // ...and then start a new search for the rest of the password.\n          i = j;\n          break;\n        }\n      }\n    }\n    return matches;\n  }\n}\nexport { MatchSpatial as default };","map":{"version":3,"names":["extend","sorted","zxcvbnOptions","MatchSpatial","constructor","SHIFTED_RX","match","password","matches","Object","keys","graphs","forEach","graphName","graph","helper","checkIfShifted","index","includes","test","charAt","shiftedCount","i","passwordLength","length","j","lastDirection","turns","prevChar","adjacents","found","foundDirection","curDirection","curChar","adjacentsLength","k","adjacent","adjacentIndex","indexOf","push","pattern","token","slice","default"],"sources":["C:/Users/j-mai/Documents/CBLXToolPFP/frontend/node_modules/@zxcvbn-ts/core/dist/matcher/spatial/matching.esm.js"],"sourcesContent":["import { extend, sorted } from '../../helper.esm.js';\nimport { zxcvbnOptions } from '../../Options.esm.js';\n\n/*\n * ------------------------------------------------------------------------------\n * spatial match (qwerty/dvorak/keypad and so on) -----------------------------------------\n * ------------------------------------------------------------------------------\n */\nclass MatchSpatial {\n  constructor() {\n    this.SHIFTED_RX = /[~!@#$%^&*()_+QWERTYUIOP{}|ASDFGHJKL:\"ZXCVBNM<>?]/;\n  }\n  match({\n    password\n  }) {\n    const matches = [];\n    Object.keys(zxcvbnOptions.graphs).forEach(graphName => {\n      const graph = zxcvbnOptions.graphs[graphName];\n      extend(matches, this.helper(password, graph, graphName));\n    });\n    return sorted(matches);\n  }\n  checkIfShifted(graphName, password, index) {\n    if (!graphName.includes('keypad') &&\n    // initial character is shifted\n    this.SHIFTED_RX.test(password.charAt(index))) {\n      return 1;\n    }\n    return 0;\n  }\n  // eslint-disable-next-line complexity, max-statements\n  helper(password, graph, graphName) {\n    let shiftedCount;\n    const matches = [];\n    let i = 0;\n    const passwordLength = password.length;\n    while (i < passwordLength - 1) {\n      let j = i + 1;\n      let lastDirection = null;\n      let turns = 0;\n      shiftedCount = this.checkIfShifted(graphName, password, i);\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        const prevChar = password.charAt(j - 1);\n        const adjacents = graph[prevChar] || [];\n        let found = false;\n        let foundDirection = -1;\n        let curDirection = -1;\n        // consider growing pattern by one character if j hasn't gone over the edge.\n        if (j < passwordLength) {\n          const curChar = password.charAt(j);\n          const adjacentsLength = adjacents.length;\n          for (let k = 0; k < adjacentsLength; k += 1) {\n            const adjacent = adjacents[k];\n            curDirection += 1;\n            // eslint-disable-next-line max-depth\n            if (adjacent) {\n              const adjacentIndex = adjacent.indexOf(curChar);\n              // eslint-disable-next-line max-depth\n              if (adjacentIndex !== -1) {\n                found = true;\n                foundDirection = curDirection;\n                // eslint-disable-next-line max-depth\n                if (adjacentIndex === 1) {\n                  // # index 1 in the adjacency means the key is shifted,\n                  // # 0 means unshifted: A vs a, % vs 5, etc.\n                  // # for example, 'q' is adjacent to the entry '2@'.\n                  // # @ is shifted w/ index 1, 2 is unshifted.\n                  shiftedCount += 1;\n                }\n                // eslint-disable-next-line max-depth\n                if (lastDirection !== foundDirection) {\n                  // # adding a turn is correct even in the initial\n                  // case when last_direction is null:\n                  // # every spatial pattern starts with a turn.\n                  turns += 1;\n                  lastDirection = foundDirection;\n                }\n                break;\n              }\n            }\n          }\n        }\n        // if the current pattern continued, extend j and try to grow again\n        if (found) {\n          j += 1;\n          // otherwise push the pattern discovered so far, if any...\n        } else {\n          // don't consider length 1 or 2 chains.\n          if (j - i > 2) {\n            matches.push({\n              pattern: 'spatial',\n              i,\n              j: j - 1,\n              token: password.slice(i, j),\n              graph: graphName,\n              turns,\n              shiftedCount\n            });\n          }\n          // ...and then start a new search for the rest of the password.\n          i = j;\n          break;\n        }\n      }\n    }\n    return matches;\n  }\n}\n\nexport { MatchSpatial as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import utils from './utils.esm.js';\nimport estimateGuesses from './estimate.esm.js';\nimport { MIN_GUESSES_BEFORE_GROWING_SEQUENCE } from '../data/const.esm.js';\nconst scoringHelper = {\n  password: '',\n  optimal: {},\n  excludeAdditive: false,\n  separatorRegex: undefined,\n  fillArray(size, valueType) {\n    const result = [];\n    for (let i = 0; i < size; i += 1) {\n      let value = [];\n      if (valueType === 'object') {\n        value = {};\n      }\n      result.push(value);\n    }\n    return result;\n  },\n  // helper: make bruteforce match objects spanning i to j, inclusive.\n  makeBruteforceMatch(i, j) {\n    return {\n      pattern: 'bruteforce',\n      token: this.password.slice(i, +j + 1 || 9e9),\n      i,\n      j\n    };\n  },\n  // helper: considers whether a length-sequenceLength\n  // sequence ending at match m is better (fewer guesses)\n  // than previously encountered sequences, updating state if so.\n  update(match, sequenceLength) {\n    const k = match.j;\n    const estimatedMatch = estimateGuesses(match, this.password);\n    let pi = estimatedMatch.guesses;\n    if (sequenceLength > 1) {\n      // we're considering a length-sequenceLength sequence ending with match m:\n      // obtain the product term in the minimization function by multiplying m's guesses\n      // by the product of the length-(sequenceLength-1)\n      // sequence ending just before m, at m.i - 1.\n      pi *= this.optimal.pi[estimatedMatch.i - 1][sequenceLength - 1];\n    }\n    // calculate the minimization func\n    let g = utils.factorial(sequenceLength) * pi;\n    if (!this.excludeAdditive) {\n      g += MIN_GUESSES_BEFORE_GROWING_SEQUENCE ** (sequenceLength - 1);\n    }\n    // update state if new best.\n    // first see if any competing sequences covering this prefix,\n    // with sequenceLength or fewer matches,\n    // fare better than this sequence. if so, skip it and return.\n    let shouldSkip = false;\n    Object.keys(this.optimal.g[k]).forEach(competingPatternLength => {\n      const competingMetricMatch = this.optimal.g[k][competingPatternLength];\n      if (parseInt(competingPatternLength, 10) <= sequenceLength) {\n        if (competingMetricMatch <= g) {\n          shouldSkip = true;\n        }\n      }\n    });\n    if (!shouldSkip) {\n      // this sequence might be part of the final optimal sequence.\n      this.optimal.g[k][sequenceLength] = g;\n      this.optimal.m[k][sequenceLength] = estimatedMatch;\n      this.optimal.pi[k][sequenceLength] = pi;\n    }\n  },\n  // helper: evaluate bruteforce matches ending at passwordCharIndex.\n  bruteforceUpdate(passwordCharIndex) {\n    // see if a single bruteforce match spanning the passwordCharIndex-prefix is optimal.\n    let match = this.makeBruteforceMatch(0, passwordCharIndex);\n    this.update(match, 1);\n    for (let i = 1; i <= passwordCharIndex; i += 1) {\n      // generate passwordCharIndex bruteforce matches, spanning from (i=1, j=passwordCharIndex) up to (i=passwordCharIndex, j=passwordCharIndex).\n      // see if adding these new matches to any of the sequences in optimal[i-1]\n      // leads to new bests.\n      match = this.makeBruteforceMatch(i, passwordCharIndex);\n      const tmp = this.optimal.m[i - 1];\n      // eslint-disable-next-line no-loop-func\n      Object.keys(tmp).forEach(sequenceLength => {\n        const lastMatch = tmp[sequenceLength];\n        // corner: an optimal sequence will never have two adjacent bruteforce matches.\n        // it is strictly better to have a single bruteforce match spanning the same region:\n        // same contribution to the guess product with a lower length.\n        // --> safe to skip those cases.\n        if (lastMatch.pattern !== 'bruteforce') {\n          // try adding m to this length-sequenceLength sequence.\n          this.update(match, parseInt(sequenceLength, 10) + 1);\n        }\n      });\n    }\n  },\n  // helper: step backwards through optimal.m starting at the end,\n  // constructing the final optimal match sequence.\n  unwind(passwordLength) {\n    const optimalMatchSequence = [];\n    let k = passwordLength - 1;\n    // find the final best sequence length and score\n    let sequenceLength = 0;\n    // eslint-disable-next-line no-loss-of-precision\n    let g = 2e308;\n    const temp = this.optimal.g[k];\n    // safety check for empty passwords\n    if (temp) {\n      Object.keys(temp).forEach(candidateSequenceLength => {\n        const candidateMetricMatch = temp[candidateSequenceLength];\n        if (candidateMetricMatch < g) {\n          sequenceLength = parseInt(candidateSequenceLength, 10);\n          g = candidateMetricMatch;\n        }\n      });\n    }\n    while (k >= 0) {\n      const match = this.optimal.m[k][sequenceLength];\n      optimalMatchSequence.unshift(match);\n      k = match.i - 1;\n      sequenceLength -= 1;\n    }\n    return optimalMatchSequence;\n  }\n};\nvar scoring = {\n  // ------------------------------------------------------------------------------\n  // search --- most guessable match sequence -------------------------------------\n  // ------------------------------------------------------------------------------\n  //\n  // takes a sequence of overlapping matches, returns the non-overlapping sequence with\n  // minimum guesses. the following is a O(l_max * (n + m)) dynamic programming algorithm\n  // for a length-n password with m candidate matches. l_max is the maximum optimal\n  // sequence length spanning each prefix of the password. In practice it rarely exceeds 5 and the\n  // search terminates rapidly.\n  //\n  // the optimal \"minimum guesses\" sequence is here defined to be the sequence that\n  // minimizes the following function:\n  //\n  //    g = sequenceLength! * Product(m.guesses for m in sequence) + D^(sequenceLength - 1)\n  //\n  // where sequenceLength is the length of the sequence.\n  //\n  // the factorial term is the number of ways to order sequenceLength patterns.\n  //\n  // the D^(sequenceLength-1) term is another length penalty, roughly capturing the idea that an\n  // attacker will try lower-length sequences first before trying length-sequenceLength sequences.\n  //\n  // for example, consider a sequence that is date-repeat-dictionary.\n  //  - an attacker would need to try other date-repeat-dictionary combinations,\n  //    hence the product term.\n  //  - an attacker would need to try repeat-date-dictionary, dictionary-repeat-date,\n  //    ..., hence the factorial term.\n  //  - an attacker would also likely try length-1 (dictionary) and length-2 (dictionary-date)\n  //    sequences before length-3. assuming at minimum D guesses per pattern type,\n  //    D^(sequenceLength-1) approximates Sum(D^i for i in [1..sequenceLength-1]\n  //\n  // ------------------------------------------------------------------------------\n  mostGuessableMatchSequence(password, matches, excludeAdditive = false) {\n    scoringHelper.password = password;\n    scoringHelper.excludeAdditive = excludeAdditive;\n    const passwordLength = password.length;\n    // partition matches into sublists according to ending index j\n    let matchesByCoordinateJ = scoringHelper.fillArray(passwordLength, 'array');\n    matches.forEach(match => {\n      matchesByCoordinateJ[match.j].push(match);\n    });\n    // small detail: for deterministic output, sort each sublist by i.\n    matchesByCoordinateJ = matchesByCoordinateJ.map(match => match.sort((m1, m2) => m1.i - m2.i));\n    scoringHelper.optimal = {\n      // optimal.m[k][sequenceLength] holds final match in the best length-sequenceLength\n      // match sequence covering the\n      // password prefix up to k, inclusive.\n      // if there is no length-sequenceLength sequence that scores better (fewer guesses) than\n      // a shorter match sequence spanning the same prefix,\n      // optimal.m[k][sequenceLength] is undefined.\n      m: scoringHelper.fillArray(passwordLength, 'object'),\n      // same structure as optimal.m -- holds the product term Prod(m.guesses for m in sequence).\n      // optimal.pi allows for fast (non-looping) updates to the minimization function.\n      pi: scoringHelper.fillArray(passwordLength, 'object'),\n      // same structure as optimal.m -- holds the overall metric.\n      g: scoringHelper.fillArray(passwordLength, 'object')\n    };\n    for (let k = 0; k < passwordLength; k += 1) {\n      matchesByCoordinateJ[k].forEach(match => {\n        if (match.i > 0) {\n          Object.keys(scoringHelper.optimal.m[match.i - 1]).forEach(sequenceLength => {\n            scoringHelper.update(match, parseInt(sequenceLength, 10) + 1);\n          });\n        } else {\n          scoringHelper.update(match, 1);\n        }\n      });\n      scoringHelper.bruteforceUpdate(k);\n    }\n    const optimalMatchSequence = scoringHelper.unwind(passwordLength);\n    const optimalSequenceLength = optimalMatchSequence.length;\n    const guesses = this.getGuesses(password, optimalSequenceLength);\n    return {\n      password,\n      guesses,\n      guessesLog10: utils.log10(guesses),\n      sequence: optimalMatchSequence\n    };\n  },\n  getGuesses(password, optimalSequenceLength) {\n    const passwordLength = password.length;\n    let guesses = 0;\n    if (password.length === 0) {\n      guesses = 1;\n    } else {\n      guesses = scoringHelper.optimal.g[passwordLength - 1][optimalSequenceLength];\n    }\n    return guesses;\n  }\n};\nexport { scoring as default };","map":{"version":3,"names":["utils","estimateGuesses","MIN_GUESSES_BEFORE_GROWING_SEQUENCE","scoringHelper","password","optimal","excludeAdditive","separatorRegex","undefined","fillArray","size","valueType","result","i","value","push","makeBruteforceMatch","j","pattern","token","slice","update","match","sequenceLength","k","estimatedMatch","pi","guesses","g","factorial","shouldSkip","Object","keys","forEach","competingPatternLength","competingMetricMatch","parseInt","m","bruteforceUpdate","passwordCharIndex","tmp","lastMatch","unwind","passwordLength","optimalMatchSequence","temp","candidateSequenceLength","candidateMetricMatch","unshift","scoring","mostGuessableMatchSequence","matches","length","matchesByCoordinateJ","map","sort","m1","m2","optimalSequenceLength","getGuesses","guessesLog10","log10","sequence","default"],"sources":["C:/Users/j-mai/Documents/CBLXToolPFP/frontend/node_modules/@zxcvbn-ts/core/dist/scoring/index.esm.js"],"sourcesContent":["import utils from './utils.esm.js';\nimport estimateGuesses from './estimate.esm.js';\nimport { MIN_GUESSES_BEFORE_GROWING_SEQUENCE } from '../data/const.esm.js';\n\nconst scoringHelper = {\n  password: '',\n  optimal: {},\n  excludeAdditive: false,\n  separatorRegex: undefined,\n  fillArray(size, valueType) {\n    const result = [];\n    for (let i = 0; i < size; i += 1) {\n      let value = [];\n      if (valueType === 'object') {\n        value = {};\n      }\n      result.push(value);\n    }\n    return result;\n  },\n  // helper: make bruteforce match objects spanning i to j, inclusive.\n  makeBruteforceMatch(i, j) {\n    return {\n      pattern: 'bruteforce',\n      token: this.password.slice(i, +j + 1 || 9e9),\n      i,\n      j\n    };\n  },\n  // helper: considers whether a length-sequenceLength\n  // sequence ending at match m is better (fewer guesses)\n  // than previously encountered sequences, updating state if so.\n  update(match, sequenceLength) {\n    const k = match.j;\n    const estimatedMatch = estimateGuesses(match, this.password);\n    let pi = estimatedMatch.guesses;\n    if (sequenceLength > 1) {\n      // we're considering a length-sequenceLength sequence ending with match m:\n      // obtain the product term in the minimization function by multiplying m's guesses\n      // by the product of the length-(sequenceLength-1)\n      // sequence ending just before m, at m.i - 1.\n      pi *= this.optimal.pi[estimatedMatch.i - 1][sequenceLength - 1];\n    }\n    // calculate the minimization func\n    let g = utils.factorial(sequenceLength) * pi;\n    if (!this.excludeAdditive) {\n      g += MIN_GUESSES_BEFORE_GROWING_SEQUENCE ** (sequenceLength - 1);\n    }\n    // update state if new best.\n    // first see if any competing sequences covering this prefix,\n    // with sequenceLength or fewer matches,\n    // fare better than this sequence. if so, skip it and return.\n    let shouldSkip = false;\n    Object.keys(this.optimal.g[k]).forEach(competingPatternLength => {\n      const competingMetricMatch = this.optimal.g[k][competingPatternLength];\n      if (parseInt(competingPatternLength, 10) <= sequenceLength) {\n        if (competingMetricMatch <= g) {\n          shouldSkip = true;\n        }\n      }\n    });\n    if (!shouldSkip) {\n      // this sequence might be part of the final optimal sequence.\n      this.optimal.g[k][sequenceLength] = g;\n      this.optimal.m[k][sequenceLength] = estimatedMatch;\n      this.optimal.pi[k][sequenceLength] = pi;\n    }\n  },\n  // helper: evaluate bruteforce matches ending at passwordCharIndex.\n  bruteforceUpdate(passwordCharIndex) {\n    // see if a single bruteforce match spanning the passwordCharIndex-prefix is optimal.\n    let match = this.makeBruteforceMatch(0, passwordCharIndex);\n    this.update(match, 1);\n    for (let i = 1; i <= passwordCharIndex; i += 1) {\n      // generate passwordCharIndex bruteforce matches, spanning from (i=1, j=passwordCharIndex) up to (i=passwordCharIndex, j=passwordCharIndex).\n      // see if adding these new matches to any of the sequences in optimal[i-1]\n      // leads to new bests.\n      match = this.makeBruteforceMatch(i, passwordCharIndex);\n      const tmp = this.optimal.m[i - 1];\n      // eslint-disable-next-line no-loop-func\n      Object.keys(tmp).forEach(sequenceLength => {\n        const lastMatch = tmp[sequenceLength];\n        // corner: an optimal sequence will never have two adjacent bruteforce matches.\n        // it is strictly better to have a single bruteforce match spanning the same region:\n        // same contribution to the guess product with a lower length.\n        // --> safe to skip those cases.\n        if (lastMatch.pattern !== 'bruteforce') {\n          // try adding m to this length-sequenceLength sequence.\n          this.update(match, parseInt(sequenceLength, 10) + 1);\n        }\n      });\n    }\n  },\n  // helper: step backwards through optimal.m starting at the end,\n  // constructing the final optimal match sequence.\n  unwind(passwordLength) {\n    const optimalMatchSequence = [];\n    let k = passwordLength - 1;\n    // find the final best sequence length and score\n    let sequenceLength = 0;\n    // eslint-disable-next-line no-loss-of-precision\n    let g = 2e308;\n    const temp = this.optimal.g[k];\n    // safety check for empty passwords\n    if (temp) {\n      Object.keys(temp).forEach(candidateSequenceLength => {\n        const candidateMetricMatch = temp[candidateSequenceLength];\n        if (candidateMetricMatch < g) {\n          sequenceLength = parseInt(candidateSequenceLength, 10);\n          g = candidateMetricMatch;\n        }\n      });\n    }\n    while (k >= 0) {\n      const match = this.optimal.m[k][sequenceLength];\n      optimalMatchSequence.unshift(match);\n      k = match.i - 1;\n      sequenceLength -= 1;\n    }\n    return optimalMatchSequence;\n  }\n};\nvar scoring = {\n  // ------------------------------------------------------------------------------\n  // search --- most guessable match sequence -------------------------------------\n  // ------------------------------------------------------------------------------\n  //\n  // takes a sequence of overlapping matches, returns the non-overlapping sequence with\n  // minimum guesses. the following is a O(l_max * (n + m)) dynamic programming algorithm\n  // for a length-n password with m candidate matches. l_max is the maximum optimal\n  // sequence length spanning each prefix of the password. In practice it rarely exceeds 5 and the\n  // search terminates rapidly.\n  //\n  // the optimal \"minimum guesses\" sequence is here defined to be the sequence that\n  // minimizes the following function:\n  //\n  //    g = sequenceLength! * Product(m.guesses for m in sequence) + D^(sequenceLength - 1)\n  //\n  // where sequenceLength is the length of the sequence.\n  //\n  // the factorial term is the number of ways to order sequenceLength patterns.\n  //\n  // the D^(sequenceLength-1) term is another length penalty, roughly capturing the idea that an\n  // attacker will try lower-length sequences first before trying length-sequenceLength sequences.\n  //\n  // for example, consider a sequence that is date-repeat-dictionary.\n  //  - an attacker would need to try other date-repeat-dictionary combinations,\n  //    hence the product term.\n  //  - an attacker would need to try repeat-date-dictionary, dictionary-repeat-date,\n  //    ..., hence the factorial term.\n  //  - an attacker would also likely try length-1 (dictionary) and length-2 (dictionary-date)\n  //    sequences before length-3. assuming at minimum D guesses per pattern type,\n  //    D^(sequenceLength-1) approximates Sum(D^i for i in [1..sequenceLength-1]\n  //\n  // ------------------------------------------------------------------------------\n  mostGuessableMatchSequence(password, matches, excludeAdditive = false) {\n    scoringHelper.password = password;\n    scoringHelper.excludeAdditive = excludeAdditive;\n    const passwordLength = password.length;\n    // partition matches into sublists according to ending index j\n    let matchesByCoordinateJ = scoringHelper.fillArray(passwordLength, 'array');\n    matches.forEach(match => {\n      matchesByCoordinateJ[match.j].push(match);\n    });\n    // small detail: for deterministic output, sort each sublist by i.\n    matchesByCoordinateJ = matchesByCoordinateJ.map(match => match.sort((m1, m2) => m1.i - m2.i));\n    scoringHelper.optimal = {\n      // optimal.m[k][sequenceLength] holds final match in the best length-sequenceLength\n      // match sequence covering the\n      // password prefix up to k, inclusive.\n      // if there is no length-sequenceLength sequence that scores better (fewer guesses) than\n      // a shorter match sequence spanning the same prefix,\n      // optimal.m[k][sequenceLength] is undefined.\n      m: scoringHelper.fillArray(passwordLength, 'object'),\n      // same structure as optimal.m -- holds the product term Prod(m.guesses for m in sequence).\n      // optimal.pi allows for fast (non-looping) updates to the minimization function.\n      pi: scoringHelper.fillArray(passwordLength, 'object'),\n      // same structure as optimal.m -- holds the overall metric.\n      g: scoringHelper.fillArray(passwordLength, 'object')\n    };\n    for (let k = 0; k < passwordLength; k += 1) {\n      matchesByCoordinateJ[k].forEach(match => {\n        if (match.i > 0) {\n          Object.keys(scoringHelper.optimal.m[match.i - 1]).forEach(sequenceLength => {\n            scoringHelper.update(match, parseInt(sequenceLength, 10) + 1);\n          });\n        } else {\n          scoringHelper.update(match, 1);\n        }\n      });\n      scoringHelper.bruteforceUpdate(k);\n    }\n    const optimalMatchSequence = scoringHelper.unwind(passwordLength);\n    const optimalSequenceLength = optimalMatchSequence.length;\n    const guesses = this.getGuesses(password, optimalSequenceLength);\n    return {\n      password,\n      guesses,\n      guessesLog10: utils.log10(guesses),\n      sequence: optimalMatchSequence\n    };\n  },\n  getGuesses(password, optimalSequenceLength) {\n    const passwordLength = password.length;\n    let guesses = 0;\n    if (password.length === 0) {\n      guesses = 1;\n    } else {\n      guesses = scoringHelper.optimal.g[passwordLength - 1][optimalSequenceLength];\n    }\n    return guesses;\n  }\n};\n\nexport { scoring as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}